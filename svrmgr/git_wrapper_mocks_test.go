// Code generated by MockGen. DO NOT EDIT.
// Source: git_wrapper.go

// Package svrmgr is a generated GoMock package.
package svrmgr

import (
	context "context"
	reflect "reflect"

	gomock "github.com/golang/mock/gomock"
)

// MockGitWrapper is a mock of GitWrapper interface.
type MockGitWrapper struct {
	ctrl     *gomock.Controller
	recorder *MockGitWrapperMockRecorder
}

// MockGitWrapperMockRecorder is the mock recorder for MockGitWrapper.
type MockGitWrapperMockRecorder struct {
	mock *MockGitWrapper
}

// NewMockGitWrapper creates a new mock instance.
func NewMockGitWrapper(ctrl *gomock.Controller) *MockGitWrapper {
	mock := &MockGitWrapper{ctrl: ctrl}
	mock.recorder = &MockGitWrapperMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockGitWrapper) EXPECT() *MockGitWrapperMockRecorder {
	return m.recorder
}

// Checkout mocks base method.
func (m *MockGitWrapper) Checkout(arg0 context.Context, arg1 GitReference) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Checkout", arg0, arg1)
	ret0, _ := ret[0].(error)
	return ret0
}

// Checkout indicates an expected call of Checkout.
func (mr *MockGitWrapperMockRecorder) Checkout(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Checkout", reflect.TypeOf((*MockGitWrapper)(nil).Checkout), arg0, arg1)
}

// DeleteBranches mocks base method.
func (m *MockGitWrapper) DeleteBranches(ctx context.Context, provider Provider, refs []GitReference) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DeleteBranches", ctx, provider, refs)
	ret0, _ := ret[0].(error)
	return ret0
}

// DeleteBranches indicates an expected call of DeleteBranches.
func (mr *MockGitWrapperMockRecorder) DeleteBranches(ctx, provider, refs interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteBranches", reflect.TypeOf((*MockGitWrapper)(nil).DeleteBranches), ctx, provider, refs)
}

// GetCurrentHead mocks base method.
func (m *MockGitWrapper) GetCurrentHead(arg0 context.Context) (GitReference, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetCurrentHead", arg0)
	ret0, _ := ret[0].(GitReference)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetCurrentHead indicates an expected call of GetCurrentHead.
func (mr *MockGitWrapperMockRecorder) GetCurrentHead(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetCurrentHead", reflect.TypeOf((*MockGitWrapper)(nil).GetCurrentHead), arg0)
}

// IsDirClean mocks base method.
func (m *MockGitWrapper) IsDirClean(ctx context.Context) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsDirClean", ctx)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// IsDirClean indicates an expected call of IsDirClean.
func (mr *MockGitWrapperMockRecorder) IsDirClean(ctx interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsDirClean", reflect.TypeOf((*MockGitWrapper)(nil).IsDirClean), ctx)
}

// ListBranches mocks base method.
func (m *MockGitWrapper) ListBranches(ctx context.Context, provider Provider, filters []string) ([]GitReference, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ListBranches", ctx, provider, filters)
	ret0, _ := ret[0].([]GitReference)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListBranches indicates an expected call of ListBranches.
func (mr *MockGitWrapperMockRecorder) ListBranches(ctx, provider, filters interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListBranches", reflect.TypeOf((*MockGitWrapper)(nil).ListBranches), ctx, provider, filters)
}

// RunGitCommand mocks base method.
func (m *MockGitWrapper) RunGitCommand(ctx context.Context, args ...string) (string, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "RunGitCommand", varargs...)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// RunGitCommand indicates an expected call of RunGitCommand.
func (mr *MockGitWrapperMockRecorder) RunGitCommand(ctx interface{}, args ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx}, args...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RunGitCommand", reflect.TypeOf((*MockGitWrapper)(nil).RunGitCommand), varargs...)
}
