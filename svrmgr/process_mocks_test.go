// Code generated by MockGen. DO NOT EDIT.
// Source: process.go

// Package svrmgr is a generated GoMock package.
package svrmgr

import (
	context "context"
	exec "os/exec"
	reflect "reflect"

	gomock "github.com/golang/mock/gomock"
)

// MockServerProcess is a mock of ServerProcess interface.
type MockServerProcess struct {
	ctrl     *gomock.Controller
	recorder *MockServerProcessMockRecorder
}

// MockServerProcessMockRecorder is the mock recorder for MockServerProcess.
type MockServerProcessMockRecorder struct {
	mock *MockServerProcess
}

// NewMockServerProcess creates a new mock instance.
func NewMockServerProcess(ctrl *gomock.Controller) *MockServerProcess {
	mock := &MockServerProcess{ctrl: ctrl}
	mock.recorder = &MockServerProcessMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockServerProcess) EXPECT() *MockServerProcessMockRecorder {
	return m.recorder
}

// EndReadOutput mocks base method.
func (m *MockServerProcess) EndReadOutput() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "EndReadOutput")
}

// EndReadOutput indicates an expected call of EndReadOutput.
func (mr *MockServerProcessMockRecorder) EndReadOutput() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "EndReadOutput", reflect.TypeOf((*MockServerProcess)(nil).EndReadOutput))
}

// IsRunning mocks base method.
func (m *MockServerProcess) IsRunning() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsRunning")
	ret0, _ := ret[0].(bool)
	return ret0
}

// IsRunning indicates an expected call of IsRunning.
func (mr *MockServerProcessMockRecorder) IsRunning() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsRunning", reflect.TypeOf((*MockServerProcess)(nil).IsRunning))
}

// Kill mocks base method.
func (m *MockServerProcess) Kill() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Kill")
	ret0, _ := ret[0].(error)
	return ret0
}

// Kill indicates an expected call of Kill.
func (mr *MockServerProcessMockRecorder) Kill() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Kill", reflect.TypeOf((*MockServerProcess)(nil).Kill))
}

// SendInput mocks base method.
func (m *MockServerProcess) SendInput(line string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SendInput", line)
	ret0, _ := ret[0].(error)
	return ret0
}

// SendInput indicates an expected call of SendInput.
func (mr *MockServerProcessMockRecorder) SendInput(line interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SendInput", reflect.TypeOf((*MockServerProcess)(nil).SendInput), line)
}

// SetCmd mocks base method.
func (m *MockServerProcess) SetCmd(cmd *exec.Cmd) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "SetCmd", cmd)
}

// SetCmd indicates an expected call of SetCmd.
func (mr *MockServerProcessMockRecorder) SetCmd(cmd interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetCmd", reflect.TypeOf((*MockServerProcess)(nil).SetCmd), cmd)
}

// Start mocks base method.
func (m *MockServerProcess) Start(ctx context.Context, provider Provider) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Start", ctx, provider)
	ret0, _ := ret[0].(error)
	return ret0
}

// Start indicates an expected call of Start.
func (mr *MockServerProcessMockRecorder) Start(ctx, provider interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Start", reflect.TypeOf((*MockServerProcess)(nil).Start), ctx, provider)
}

// StartReadOutput mocks base method.
func (m *MockServerProcess) StartReadOutput(c chan string) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "StartReadOutput", c)
}

// StartReadOutput indicates an expected call of StartReadOutput.
func (mr *MockServerProcessMockRecorder) StartReadOutput(c interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "StartReadOutput", reflect.TypeOf((*MockServerProcess)(nil).StartReadOutput), c)
}
